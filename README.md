# var  (ES6이전)

- 재할당, 재선언 가능
- 호이스팅
  - 선언 하는 순간 undefined를 할당해 초기화
  - 변수 선언 이전의 위치에서 접근 시 undefined를 반환
- 함수 스코프
  - 함수 바깥에서 접근 불가능

# let (ES6 이후)

- 재할당은 가능하지만 재선언 불가능
- 선언하기전에 호출하면 에러
- 블록 스코프
  - 함수, if,for,while,try/catch 등을 지역 스코프로 인정해서 전역 변수는 변하지 않는다.
- 변수는 let으로 사용

# const (ES6 이후)

- 재할당,재선언 불가능
  - 객체인 경우 객체 안의 속성은 재할당 가능
- 선언할 때 초기화를 동시에 진행해야 함 ( 값 넣기)
- 블록 스코프
  - 함수, if,for,while,try/catch 등을 지역 스코프로 인정해서 전역 변수는 변하지 않는다.
- 상수는 웬만하면 const로 이용 

# 세미콜론

- JS는 세미콜론을 선택적으로 사용 가능
- 세미콜론이 없을 경우 ASI에 의해 자동으로 삽입
  - ASI (Automatic Semicolon Insertion)

# 변수 & 식별자

- 식별자는 변수를 구분할 수 있는 변수명
- 반드시 문자, 달러($), 밑줄(_)로 시작
- 대소문자를 구분, 클래스명 외에는 모두 소문자로 시작
- 예약어 사용 불가능
  - if, for, case...
- 카멜 케이스
  - 변수,객체,함수에 사용
  - camelCase - 두번째 단어의 첫글자부터 대문자
- 파스칼 케이스
  - PascalCase - 모든 단어의 첫번째 글자를 대문자
  - 클래스, 생성자에 사용
- 대문자 스네이크 케이스
  - 상수에 사용
    - 변경될 가능성이 없는 값
  - SNAKE_CASE - 모든 글자 대문자, 단어 사이에 언더스코어

- 선언
  - 변수를 생성하는 행위, 시점
- 할당
  - 선언된 변수에 값을 저장하는 행위, 시점
- 초기화
  - 선언된 변수에 처음으로 값을 저장하는 행위, 시점

# 데이터 타입

- 원시 타입 ( Primtive)
  - 숫자, 문자, 논리,, undefined, null...
    - 숫자
      - Infinity(무한), -Infinity(음의 무한), NaN(계산 불가능한 경우)
    - 문자
      - 텍스트 데이터, 작은 따옴표 사용 가능
      - 템플릿 리터럴
        - ES6부터 지원
        - backtick(``)으로 표현
        - ${expression}형태로 표현식 삽입
    - undefined
      - 변수의 값이 없음을 나타냄
      - 직접 값을 할당하지 않으면 JS가 자동으로 undefined  할당함
      - typeof 연산자의 결과로 undefined 
    - null
      - 변수의 값이 없음을 의도적으로 표현
      - 개발자가 의도적으로 필요에 의해 할당
      - typeof 연산자의 결과로는 객체로 표현(ECMA명세로는 원시타입)
  - 객체가 아닌 기본 타입
  - 변수에 해당 타입의 값이 담김
  - 다른 변수에 복사할 때 실제 값이 복사됨
  - ![image-20220316222725566](README.assets/image-20220316222725566.png)
- 참조 타입 ( Referencne)
  - Objects, Array, Function
  - 객체 타입의 자료형
  - 변수에 해당 객체의 참조 값이 담김
  - 다른 변수에 복사할 때 참조 값이 복사됨

# 연산자

- 비교 연산자
  - 알파벳 
    - 오름차순으로 우선순위( 'z' > 'a' )
    - 소문자가 대문자보다 우선순위( 'a' > 'A' )
- 동등 비교 연산자 (==)
  - 암묵적 타입 변환을 통해 타입을 일치시킨 후 비교 (웬만하면 확실한 비교를 하는게 좋음)
  - 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
  - ![image-20220316223348914](README.assets/image-20220316223348914.png)

- 일치 비교 연산자 (===)
  - 엄격한 비교가 이루어짐 ( 암묵적 타입 변환X)
  - ![image-20220316223458292](README.assets/image-20220316223458292.png)
- 논리 연산자
  - and : &&
  - or : ||
  - not : !
  - 단축 평가 지원
- 삼항 연산자
  - 세 개의 피연산자를 사용하여 조건에 따라 값 반환
  - 조건식이 참이면 콜론 앞의 값,  거짓이면 클론 뒤의 값

# 조건문

- if statement (if, else if, else)
  - 결과값을 Boolean 타입으로 변환
  - 블록 스코프 생성
  - 조건은 소괄호 안에 작성
  - 실행할 코드는 중괄호 안에 작성
  - ![image-20220316224350512](README.assets/image-20220316224350512.png)
- switch statement
  - 결과값이 어느 값에 해당하는지 판별
  - 표현식의 결과값과 case문의 오른쪽 값을 비교
  - break, default 문은 선택적으로 사용 가능
  - break문이 없는 경우 break문을 만나거나 default문을 실행할 때까지 다음 조건문 실행
  - 블록 스코프 생성
  - ![image-20220316224443848](README.assets/image-20220316224443848.png)

# 반복문

- while 
  - 조건 - 소괄호
  - 실행 코드 - 중괄호
  - 블록 스코프
  - ![image-20220317041715349](README.assets/image-20220317041715349.png)

- for
  - 세미콜론으로 구분
  - Initialization - 최초 반복문 진입시 1회만 실행
  - condition - 매 반복 시행 전 평가
  - expression - 매 반복 시행 이후 평가
  - 블록 스코프
  - ![image-20220317041811878](README.assets/image-20220317041811878.png)
- for .. in
  - 객체의 속성을 순회할 때 사용
  - 순서를 보장하지 않기 때문에 배열 순회는 권장 x
  - ![image-20220317041851881](README.assets/image-20220317041851881.png)

- for ... of
  - 반복 가능한 객체를 순회하며 값을 꺼냄 (Iterable)
  - ![image-20220317042058409](README.assets/image-20220317042058409.png)

- in & of 차이
  - ![image-20220317042213712](README.assets/image-20220317042213712.png)
  - for .. in 에서 iterable을 순회하면 값이 아닌 인덱스를 출력
  - for .. of 에서 객체를 순회하면 에러가 난다

# 4

